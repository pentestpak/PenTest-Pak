#include <stdlib.h>
#include <netinet/in.h>
#include <stdio.h>
#include <signal.h>
#include <string.h>

#define TCP_PORT 2432

typedef enum { false, true } bool;  //boolean variable type definition

void overFlow(int,int);
void socketNgame();

int main (int argc, char **argv) {
 
    socketNgame();

    return 0;
}



void socketNgame() {

    int sock, msgsock, client_len;
    struct sockaddr_in server, client;

    signal(SIGCHLD, SIG_IGN);
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
	    perror("creating stream socket");
	    exit(1);
    }

    server.sin_family      = AF_INET;
    server.sin_addr.s_addr = htonl(INADDR_ANY);
    server.sin_port        = htons(TCP_PORT);

    if (bind(sock, (struct sockaddr *) &server, sizeof (server)) < 0) {
	    perror("binding socket");
	    exit(2);
    }

    listen(sock, 5);
    fprintf(stderr, "server: listening...\n");

    while (1) {    
        client_len = sizeof(client);
        msgsock = accept(sock, (struct sockaddr *) &client, &client_len);
        if (msgsock < 0) {
            perror("accepting connection");
            exit(3);
    }

    if (fork() == 0) {
            close(sock);        /* Child -- Process Request */
	        printf("new child (pid %d) using descriptor %d\n", getpid(), msgsock);
            srand((int)time((long *)0));	/* Randomise the seed */
	        overFlow(msgsock, msgsock);
            printf("child (pid %d) exiting\n", getpid());
            exit(0);
        }
        else close(msgsock);
    }

}


void overFlow(int in, int out) {

    char inbuffer[1];
    char outputbuffer[100];

    char message[] = "Hey there,\n\nWe're going to go through what a buffer overflow is and what can you do to create one\n"
                        "The concept Buffer Overflow has very self-explanatory name; there is a buffer with a fixed amount\n"
                        "of memory allocated but it accepts more data that it can hold. Let's make an example out of a water cup.\n\n"
                        "Press ENTER key to continue...\n\n";
                        //getchar();

    char message2[] = "Naturally, a water cup can only hold a specific amount of water and if you try to pour more that it can hold, the water\n"
                        "will spill out of the cup. This would cause the water to spill onto places you woulnd't want water on. Sadly, we can't\n"
                        "put a safe guard on how much water a cup can take before overflowing but we can do so with software.\n\n"
                        "Press ENTER key to continue...\n\n";
                        //getchar();

    char message3[] = "Think of the cup as an array of characters or strings and the water as data that the program asks of the user, just like I'm\n"
                        "asking you to press ENTER every so often :). Usually this input is filtered and formated to prevent these types of attacks but\n"
                        "sometimes the programmer forgets about them, leaving us with a way into the system. Of course, sometimes it won't matter if they\n"
                        "didn't filter the data because the user running the program might be a very restricted user without sudo priveledges, but we\n"
                        "never know until we execute our attacks :).\n\n"
                        "Press ENTER key to continue...\n\n";
                        //getchar();


    char message4[] = "Ok so know we now what is meant by buffer overflow, right? We have a buffer and we fill the buffer with more data than it's mean to hold.\n"
                        "I'll give you a test to see if you're getting the hang it.\n\n"
                        "\tOur intern wrote a bot in C but when he compiled the code he got warnings regarding a function called 'gets()'. Can you be so kindly as\n"
                        "\tverify if the program is succestible to buffer overflows?\n\tHere's a piece of his code:\n\n\t\t50\t flag = 0;\n\t\t51\t gets(buffer);\n\n"
                        "The test here is very simple, just try to change the value of flag by overflowing the buffer :).\n" 
                        "Hint: If the bot is receives questions from the user then the buffer should be around 30 bytes, right?\n";


    write(out, message, strlen(message));
    read(in, inbuffer, 1);

    write(out, message2, strlen(message2));
    read(in, inbuffer, 1);

    write(out, message3, strlen(message3));
    read(in, inbuffer, 1);

    write(out, message4, strlen(message4));
    read(in, inbuffer, 1);

    int flag1;

    struct {
        char buffer[30];
        volatile int flag;
    } locals;

    bool test = false;

    while (test == false)
    {
        char exp[] = "\n\n\tExploit goes here: ";
        char almost[] = "\n\tStill not there yet, keep trying.\n";
        write(out, exp, strlen(exp)); 
        locals.flag=0;
        read(in, locals.buffer, 300);

        if (locals.flag != 0) test = true;
        else {
            write(out, almost, strlen(almost));
        }
        flag1 = locals.flag;
    }



    sprintf(outputbuffer,"\n\n\tCongrats! You just changed the value of flag from 0 to %x through a simple buffer overflow.\n", &flag1);
    write(out, outputbuffer, strlen(outputbuffer));

    sleep(5);

    sprintf(outputbuffer, "\nIn case you're still fuzzy about what just happend, here's a link that helped me understand what happende:\n\n\t %s\n\n", "https://www.veracode.com/security/buffer-overflow");
    write(out, outputbuffer, strlen(outputbuffer));

    sprintf(outputbuffer,"\nAlso, here's the flag: ");
    write(out,outputbuffer,strlen(outputbuffer));
    char *flag = system("cat flag.txt");


}
